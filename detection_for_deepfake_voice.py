# -*- coding: utf-8 -*-
"""Detection for Deepfake Voice.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1y6NLeYSMQQmlhuA1ppOmUQWDSo4LULS-
"""

from google.colab import drive
drive.mount('/content/drive')

import os
import librosa
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import confusion_matrix, classification_report
from sklearn.model_selection import StratifiedKFold
from sklearn.neighbors import KNeighborsClassifier
from imblearn.over_sampling import SMOTE
from sklearn.model_selection import StratifiedKFold
from imblearn.over_sampling import SMOTE
import matplotlib.pyplot as plt
import seaborn as sns

# Path setup
real_path = '/content/drive/MyDrive/Audio/Real'
fake_path = '/content/drive/MyDrive/Audio/Fake'

real_files = [os.path.join(real_path, f) for f in os.listdir(real_path) if f.endswith('.wav')]
fake_files = [os.path.join(fake_path, f) for f in os.listdir(fake_path) if f.endswith('.wav')]

def extract_features(file_path, n_mfcc=13, gender_threshold=165):
    """
    Extract MFCC means plus a simple gender flag based on avg. pitch.
    gender_threshold: Hz above which we label 'female' (1), below 'male' (0).
    """
    try:
        audio, sr = librosa.load(file_path, sr=None)

        # 1) MFCC features
        mfccs = librosa.feature.mfcc(y=audio, sr=sr, n_mfcc=n_mfcc)
        mfccs_mean = np.mean(mfccs.T, axis=0)

        # 2) Estimate fundamental freq (pitch) via YIN
        f0 = librosa.yin(audio, fmin=50, fmax=500, sr=sr)
        f0_mean = np.nanmean(f0)

        # 3) Simple gender flag: 0 = male (<= threshold), 1 = female (> threshold)
        gender_flag = 1 if f0_mean > gender_threshold else 0

        # 4) Return MFCC means + gender as extra dimension
        return np.append(mfccs_mean, gender_flag)

    except Exception as e:
        print(f"Error processing {file_path}: {e}")
        return None

# Prepare dataset
X = []
y = []

for file in real_files:
    features = extract_features(file)
    if features is not None:
        X.append(features)
        y.append(1)

for file in fake_files:
    features = extract_features(file)
    if features is not None:
        X.append(features)
        y.append(0)

X = np.array(X)
y = np.array(y)

def plot_confusion_matrix(cm, class_names, title='Confusion Matrix'):
    plt.figure(figsize=(6, 5))
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues',
                xticklabels=class_names, yticklabels=class_names)
    plt.title(title)
    plt.xlabel('Predicted')
    plt.ylabel('Actual')
    plt.show()

from sklearn.model_selection import StratifiedKFold
from sklearn.metrics import confusion_matrix
from sklearn.preprocessing import StandardScaler
from imblearn.over_sampling import SMOTE
from sklearn.neighbors import KNeighborsClassifier
import os

# Prepare tracking
y_true_all = []
y_pred_all = []

# Generate filenames list in order corresponding to X
file_names = [os.path.basename(f) for f in real_files] + [os.path.basename(f) for f in fake_files]

print("Starting 5-Fold Cross-Validation...\n")

# Initialize StratifiedKFold
skf = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)

for fold, (train_idx, test_idx) in enumerate(skf.split(X, y), 1):
    print(f"\nðŸŒ€ Fold {fold} ----------------------")

    # Show test filenames for the current fold
    test_file_names = [file_names[i] for i in test_idx]
    print("ðŸ§ª Test Set Files:")
    for name in test_file_names:
        print(f" - {name}")

    # Split and balance data
    X_train, X_test = X[train_idx], X[test_idx]
    y_train, y_test = y[train_idx], y[test_idx]

    smote = SMOTE(random_state=42)
    X_train_bal, y_train_bal = smote.fit_resample(X_train, y_train)

    # Scale features
    scaler = StandardScaler()
    X_train_bal = scaler.fit_transform(X_train_bal)
    X_test = scaler.transform(X_test)

    # Train KNN
    model = KNeighborsClassifier(n_neighbors=5)
    model.fit(X_train_bal, y_train_bal)

    # Predict
    y_pred = model.predict(X_test)
    y_true_all.extend(y_test)
    y_pred_all.extend(y_pred)

    # Confusion matrix
    cm_fold = confusion_matrix(y_test, y_pred, labels=[0, 1])
    labels = ['Fake', 'Real']

    print("\nConfusion Matrix (Text Format):")
    print(f"{labels[0]} â†’ {labels[0]}: {cm_fold[0][0]}")  # Fake â†’ Fake
    print(f"{labels[0]} â†’ {labels[1]}: {cm_fold[0][1]}")  # Fake â†’ Real
    print(f"{labels[1]} â†’ {labels[0]}: {cm_fold[1][0]}")  # Real â†’ Fake
    print(f"{labels[1]} â†’ {labels[1]}: {cm_fold[1][1]}")  # Real â†’ Real

from sklearn.metrics import accuracy_score, classification_report

# Calculate and print the overall accuracy
accuracy = accuracy_score(y_true_all, y_pred_all)
print(f"\nðŸŽ¯ Overall Accuracy: {accuracy:.4f}")

# Print detailed classification report
print("\nðŸ“Š Classification Report:")
print(classification_report(y_true_all, y_pred_all, target_names=['Fake', 'Real']))

import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import confusion_matrix, classification_report

def plot_confusion_matrix(cm, class_names, title='Confusion Matrix'):
    plt.figure(figsize=(6, 5))
    sns.heatmap(
        cm,
        annot=True,
        fmt='d',
        cmap='Blues',
        xticklabels=class_names,
        yticklabels=class_names
    )
    plt.title(title)
    plt.ylabel('Actual')
    plt.xlabel('Predicted')
    plt.tight_layout()
    plt.show()

# Compute the confusion matrix
cm = confusion_matrix(y_true_all, y_pred_all)
tn, fp, fn, tp = cm.ravel()

# Plot confusion matrix
class_names = ['Fake', 'Real']
plot_confusion_matrix(cm, class_names=class_names, title='Overall Confusion Matrix')

# Print classification report
print("\nClassification Report (After SMOTE):")
print(classification_report(y_true_all, y_pred_all, target_names=class_names))

# Final model training on full balanced dataset
X_resampled, y_resampled = smote.fit_resample(X, y)
final_scaler = StandardScaler()
X_scaled = final_scaler.fit_transform(X_resampled)

final_model = KNeighborsClassifier(n_neighbors=5)
final_model.fit(X_scaled, y_resampled)

print("Final KNN model trained on full balanced dataset.")

from pathlib import Path

# Predict a single audio file (change path as needed)
single_file_path = '/content/drive/MyDrive/Audio/Fake/biden-to-margot.wav'  # Change as needed

if Path(single_file_path).exists():
    features = extract_features(single_file_path)
    if features is not None:
        gender_flag = int(features[-1])
        gender_str = "Female" if gender_flag == 1 else "Male"

        features_scaled = final_scaler.transform([features])
        prediction = final_model.predict(features_scaled)[0]
        label_map = {1: 'Real', 0: 'Fake'}

        print(f"Gender (based on pitch): {gender_str}")
        print(f"Prediction using best model ({final_model}): {label_map[prediction]}")
    else:
        print("Feature extraction failed.")
else:
    print("File not found.")

from pathlib import Path

# Predict a single audio file (change path as needed)
single_file_path = '/content/drive/MyDrive/Audio/Fake/biden-to-musk.wav'  # Change as needed

if Path(single_file_path).exists():
    features = extract_features(single_file_path)
    if features is not None:
        gender_flag = int(features[-1])
        gender_str = "Female" if gender_flag == 1 else "Male"

        features_scaled = final_scaler.transform([features])
        prediction = final_model.predict(features_scaled)[0]
        label_map = {1: 'Real', 0: 'Fake'}

        print(f"Gender (based on pitch): {gender_str}")
        print(f"Prediction using best model ({final_model}): {label_map[prediction]}")
    else:
        print("Feature extraction failed.")
else:
    print("File not found.")

from pathlib import Path

# Predict a single audio file (change path as needed)
single_file_path = '/content/drive/MyDrive/Audio/Fake/linus-to-musk.wav'  # Change as needed

if Path(single_file_path).exists():
    features = extract_features(single_file_path)
    if features is not None:
        gender_flag = int(features[-1])
        gender_str = "Female" if gender_flag == 1 else "Male"

        features_scaled = final_scaler.transform([features])
        prediction = final_model.predict(features_scaled)[0]
        label_map = {1: 'Real', 0: 'Fake'}

        print(f"Gender (based on pitch): {gender_str}")
        print(f"Prediction using best model ({final_model}): {label_map[prediction]}")
    else:
        print("Feature extraction failed.")
else:
    print("File not found.")

from pathlib import Path

# Predict a single audio file (change path as needed)
single_file_path = '/content/drive/MyDrive/Audio/Fake/margot-to-taylor.wav'  # Change as needed

if Path(single_file_path).exists():
    features = extract_features(single_file_path)
    if features is not None:
        gender_flag = int(features[-1])
        gender_str = "Female" if gender_flag == 1 else "Male"

        features_scaled = final_scaler.transform([features])
        prediction = final_model.predict(features_scaled)[0]
        label_map = {1: 'Real', 0: 'Fake'}

        print(f"Gender (based on pitch): {gender_str}")
        print(f"Prediction using best model ({final_model}): {label_map[prediction]}")
    else:
        print("Feature extraction failed.")
else:
    print("File not found.")